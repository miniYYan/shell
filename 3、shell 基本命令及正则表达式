1、expect命令
    在运行另外一些操作(如ssh登录)时。我们无法用分界符的方法来输入多个命令，由于ssh的输入来源是终端(分界符的输入。应理解为通常意义上的字符串)。这时，我们能够考虑用expect命令。
    expect命令是Linux中专门以非交互式方法处理交互式命令的工具。相比分界符来说，它更为强大。且能实现分界符能实现的一切功能。

(1) 工作原理
    epect命令的工作原理是在shell中另启一个新进程，而且在此进程中模拟了终端，对输入、输出出进行全面监控。而要使用expect命令。则必须须要编写独立的脚本。

(2)［#! /usr/bin/expect］
    expect脚本的第一行总是用这个语法。这相似于shell脚本的#! /bin/sh。这句话的含义也是定义脚本的解释器。

    值得注意的是，依据操作系统的不同，expect命令的位置也可能是在 /usr/local/bin/expect。使用前。用户应确认工具是否存在(确认方法是在root用户下运行“which expect”命令)。

(3)［set timeout 30］
    设置响应的超时时间，计时单位是秒。设置timeout -1表示永不超时。

(4)［spawn ssh -l username ip］ 
    spawn是进入expect环境后才干够运行的expect内部命令。
    它基本的功能是给ssh运行进程加个壳，用来传递交互指令。 

(5)［expect "xxxxx:"］ 
    这里的expect也是一个内部命令。
    这个命令的意思是推断上次输出结果里是否包括“xxxxx:”的特定字符串。假设有则马上返回。
    expect还有些扩展的使用方法，最常见的例如以下所看到的：
    expect {
        “xxx1”   {command1；exp_continue}
        “xxx2”  {command 2}
    }

(6)［send "ispass\r"］ 
    这是运行交互动作，即模拟终端进行输入。值得注意的是，命令字符串结尾别忘记加上“\r”。

(7) [expect eof]

    退出expect解释器 。

2、sed命令

(1) sed命令的工作原理以及过程
    sed是一个非交互式的流编辑器。所谓非交互式，是指使用sed只能在命令行下输入编辑命令来编辑文本，然后在屏幕上查看输出；而所谓流编辑器，是指sed每次只从文件（或输入）读入一行，然后对该行进行指定的处理，并将结果输出到屏幕（除非取消了屏幕输出又没有显式地使用打印命令），接着读入下一行。整个文件像流水一样被逐行处理然后逐行输出。

    工作过程：
    sed不是在原输入上直接进行处理的，而是先将读入的行放到缓冲区中，对缓冲区里的内容进行处理，处理完毕后也不会写回原文件（除非用shell的输出重定向来保存结果），而是直接输出到屏幕上。sed运行过程中维护着两个缓冲区，一个是活动的“模式空间（pattern space）”，另一个是起辅助作用的“暂存缓冲区（holding space）”。一般情况下，每当运行sed，sed首先把第一行装入模式空间，进行处理后输出到屏幕，然后将第二行装入模式空间替换掉模式空间里原来的内容，然后进行处理，以此类推。

    一般情况下暂存缓冲区是用不到的，但有特殊的命令可以在模式空间与暂存缓冲区之间交换数据，后文将有介绍。由于sed对文本的所有操作都是在缓冲区里进行的，所以不会对原文件造成任何破坏。

(2) sed命令的选项
    sed [-Options] [‘Commands’] filename
    其中，Command是一个sed命令，sed命令一定要被包含在一对单引号中，以免被shell解释，其格式如下：
        [address-range][sed-command]或
        [Pattern-to-match][sed-command]
    address-range是指要处理的行的范围，又叫地址范围；pattern-to-match是一个要匹配的模式，是一个正则表达式，sed-command是一个sed命令，用来对指定的行进行处理。

    选项与参数：
    -n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。
    -e ：直接在命令列模式上进行 sed 的动作编辑；
    -f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；
    -r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)
    -i ：直接修改读取的文件内容，而不是输出到终端。

    function：
    a ：新增行， a 的后面可以是字串，而这些字串会在新的一行出现(目前的下一行)
    c ：取代行， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行
    d ：删除行，因为是删除，所以 d 后面通常不接任何参数，直接删除地址表示的行；
    i ：插入行， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
    p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行
    s ：替换，可以直接进行替换的工作,通常这个 s 的动作可以搭配正规表示法，例如 1,20s/old/new/g 一般是替换符合条件的字符串而不是整行

    一般function的前面会有一个地址的限制，例如 [地址]function，表示我们的动作要操作的行。下面我们通过具体的例子直观的看看sed的使用方法。

3、awk命令
    AWK是一种处理文本文件的语言，是一个强大的文本分析工具。
    语法：
        awk [选项参数] 'script' var=value file(s)
        或
        awk [选项参数] -f scriptfile var=value file(s)

（1）基本用法
    用法一：
        awk '{[pattern] action}' {filenames}   # 行匹配语句 awk '' 只能用单引号
        实例：
            # 每行按空格或TAB分割，输出文本中的1、4项
            $ awk '{print $1,$4}' log.txt

    用法二：
        awk -F  #-F相当于内置变量FS, 指定分割字符
        实例：
            # 使用","分割
            awk -F, '{print $1,$2}'   log.txt

            # 或者使用内建变量
            awk 'BEGIN{FS=","} {print $1,$2}'  log.txt

            # 使用多个分隔符.先使用空格分割，然后对分割结果再使用","分割
            awk -F '[ ,]'  '{print $1,$2,$5}'   log.txt

    用法三：
        awk -v  # 设置变量 (经常用来把shell变量引入awk程序。)
        实例：
        awk -va=1 '{print $1,$1+a}' log.txt

    用法四：
        awk -f {awk脚本} {文件名}
        实例：
        awk -f cal.awk log.txt
(2) 运算符
    运算符                      描述
    = += -= *= /= %= ^= **=     赋值
    ?:                          C条件表达式
    ||                          逻辑或
    &&                          逻辑与
    ~ ~!                        匹配正则表达式和不匹配正则表达式
    < <= > >= != ==             关系运算符
    空格                        连接
    + -                         加，减
    * / %                       乘，除与求余
    + - !                       一元加，减和逻辑非
    ^ ***                       求幂
    ++ --                       增加或减少，作为前缀或后缀
    $                           字段引用
    in                          数组成员

    实例：
        过滤第一列大于2的行
        awk '$1>2' log.txt    #命令

(3) 内置变量
    
    变量        描述
    $n          当前记录的第n个字段，字段间由FS分隔
    $0          完整的输入记录
    ARGC        命令行参数的数目
    ARGIND      命令行中当前文件的位置(从0开始算)
    ARGV        包含命令行参数的数组
    CONVFMT     数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组
    ERRNO       最后一个系统错误的描述
    FIELDWIDTHS 字段宽度列表(用空格键分隔)
    FILENAME    当前文件名
    FNR         各文件分别计数的行号
    FS          字段分隔符(默认是任何空格)
    IGNORECASE  如果为真，则进行忽略大小写的匹配
    NF          一条记录的字段的数目
    NR          已经读出的记录数，就是行号，从1开始
    OFMT        数字的输出格式(默认值是%.6g)
    OFS         输出记录分隔符（输出换行符），输出时用指定的符号代替换行符
    ORS         输出记录分隔符(默认值是一个换行符)
    RLENGTH     由match函数所匹配的字符串的长度
    RS          记录分隔符(默认是一个换行符)
    RSTART      由match函数所匹配的字符串的第一个位置
    SUBSEP      数组下标分隔符(默认值是/034)

（4）使用正则，字符串匹配
    # 输出第二列包含 "th"，并打印第二列与第四列
    awk '$2 ~ /th/ {print $2,$4}' log.txt

(5) awk脚本
    关于awk脚本，我们需要注意两个关键词BEGIN和END。
    BEGIN{ 这里面放的是执行前的语句 }
    END {这里面放的是处理完所有的行后要执行的语句 }
    {这里面放的是处理每一行时要执行的语句}
